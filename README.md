1.	Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

vagrant@vagrant:~$ type cd
cd is a shell builtin 
cd это внутренняя команда встроенная в саму оболочку. думаю это основная команда встроенная в ядро и без нее оболочка не смогла бы работать.

2.	Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

vagrant@vagrant:~$ grep 1 4 | wc -l
3
vagrant@vagrant:~$ grep –c 1 4
3
vagrant@vagrant:~$ wc -l <(grep 1 4)
3 /dev/fd/63

3.	Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

systemd
vagrant@vagrant:~$ ps --pid 1
    PID TTY          TIME CMD
      1 ?        00:00:04 systemd

4.	Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

vagrant@vagrant:~$ ls
1  4  5  bash  t2  wc
vagrant@vagrant:~$ ls 9 2>/dev/pts/1 

5.	Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

vagrant@vagrant:~$ cat tst
tst line
vagrant@vagrant:~$ cat result
cat: result: No such file or directory
vagrant@vagrant:~$ cat <tst >result
vagrant@vagrant:~$ cat result
tst line
vagrant@vagrant:~$ 

6.	Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Между терминалами можно передавать данные
vagrant@vagrant:~$ ls 9 2>/dev/pts/1 
Например передаст stderr команды ls 9 в ssh сессию tty 1  

7.	Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Создаcтся новый дескриптор 5, Все что поступает на дескриптор 5 будет выводиться в дескриптор 1 stdout  
echo netology поступает в дескриптор 5 который перенаправляет вывод на дескриптор stdout, stdout  на экране буде результат echo netology

8.	Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

vagrant@vagrant:/$ (ls && ls 2) 2>&1 1>&5 5>&2 |grep No -c
bin  boot  dev  etc  home  lib  lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap  srv  sys  tmp  usr  vagrant  var
1

9.	Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Это переменные моего окружения
env
10.	Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
Cmdline команда с помощью которой был запущен процесс
Exe сам файл процесса

11.	Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

sse4_2

12.	При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
Почитайте, почему так происходит, и как изменить поведение.

ssh localhost 'tty' просто исполняется команда не создается псевдотерминал
ssh –t localhost 'tty' –t заставит принудительно создать псевдотерминал

13.	Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

запускаю ping ya.ru
ctrl z
делаю его в фоне bg
запускаю screen
редактирую файл, без него не дает перекинуть процесс, не достаточно оправ echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope 
reptyr –T 1697 переношу процесс

14.	sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

sudo echo string > /root/new_file 
sudo echo string запущено от имени sudo  а перенаправление делается от имени обычного юзера 
 echo string | sudo tee /root/new_file здесь в правой части конвера команда tee заущена от имени sudo и с повышенными правами она сможет записать файл


